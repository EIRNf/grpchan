package shmgrpc

import (
	"bytes"
	"context"
	"net/http"
	"strings"
	"sync"
	"time"

	"github.com/fullstorydev/grpchan"
	"github.com/fullstorydev/grpchan/internal"
	jsoniter "github.com/json-iterator/go"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/encoding"
	grpcproto "google.golang.org/grpc/encoding/proto"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"

	"github.com/rs/zerolog/log"
)

// type ServeMux struct {
// 	mu    sync.RWMutex
// 	m     map[string]muxEntry
// 	es    []muxEntry
// 	hosts bool
// }

// type muxEntry struct {
// 	h       Handler
// 	pattern string
// }

// type Handler interface {
// 	ServeMethod(,)
// }

// Server is grpc over shared memory. It
// acts as a grpc ServiceRegistrar
type Server struct {
	handlers         grpchan.HandlerMap
	basePath         string
	opts             handlerOpts
	unaryInterceptor grpc.UnaryServerInterceptor

	// quit    *grpcsync.Event
	// done    *grpcsync.Event
	serveWG sync.WaitGroup

	// ErrorLog *log.Logger

	mu sync.Mutex

	// Listener accepting connections on a particular IP  and port
	lis *Listener

	prev_time time.Time

	// Map of queue pairs for boolean of active or inactive connections
	conns map[int]*QueuePair

	// ShmQueueInfo  *QueueInfo
	// responseQueue *Queue
	// requestQeuue  *Queue
}

func (s *Server) timestamp_dif() string {
	// if s.prev_time != nil {
	// 	s.prev_time = time.Now()

	// }
	dif := time.Since(s.prev_time).String()
	s.prev_time = time.Now()
	return dif
}

type Mux func(pattern string, handler func(response_queue uintptr, request []byte))

// "Listens" on the queue accept method and hands it off to a dedicate thread to manage.
// Handles the notnets layer
type Listener struct {
	mu              sync.Mutex
	notnets_context *ServerContext
	addr            string
}

// Instantiates notnets listening loop. From listener accept can be called
func Listen(addr string) *Listener {
	var lis Listener
	lis.notnets_context = RegisterServer(addr)
	lis.addr = addr
	return &lis
}

func (l *Listener) Accept() (*QueuePair, error) {
	l.mu.Lock()
	defer l.mu.Unlock()
	queue := l.notnets_context.Accept()
	var err error
	return queue, err
}

func (l *Listener) Close() error {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.notnets_context.Shutdown()
	return nil
}

func (l *Listener) Addr() string {
	return l.Addr()
}

var _ grpc.ServiceRegistrar = (*Server)(nil)

// ServerOption is an option used when constructing a NewServer.
type ServerOption interface {
	apply(*Server)
}

type serverOptFunc func(*Server)

func (fn serverOptFunc) apply(s *Server) {
	fn(s)
}

// HandlerOption is an option to customize some aspect of the HTTP handler
// behavior, such as rendering gRPC errors to HTTP responses.
//
// HandlerOptions also implement ServerOption.
type HandlerOption func(*handlerOpts)

type handlerOpts struct {
	errFunc func(context.Context, *status.Status, http.ResponseWriter)
}

func NewServer(basePath string, opts ...ServerOption) *Server {
	var s Server
	s.basePath = basePath
	s.handlers = grpchan.HandlerMap{}
	for _, o := range opts {
		o.apply(&s)
	}

	s.conns = make(map[int]*QueuePair)

	return &s
}

// Register Service, also gets generated by protoc, as Register(SERVICE NAME)Server
func (s *Server) RegisterService(desc *grpc.ServiceDesc, svr interface{}) {
	s.handlers.RegisterService(desc, svr)
	// for i := range desc.Methods {
	// 	md := desc.Methods[i]
	// 	h := handleMethod(svr, desc.ServiceName, &md, s.unaryInt, &s.opts)
	// 	s.mux.HandleFunc(path.Join(s.basePath, fmt.Sprintf("%s/%s", desc.ServiceName, md.MethodName)), h)
	// }
}

// Register method handlers for all methods exposed registered in reg
// func HandleServices(mux Mux, basePath string, reg grpchan.HandlerMap, unaryInt grpc.UnaryServerInterceptor, streamInt grpc.StreamServerInterceptor, opts ...HandlerOption) {
// 	var hOpts handlerOpts
// 	for _, opt := range opts {
// 		opt(&hOpts)
// 	}

// 	reg.ForEach(func(desc *grpc.ServiceDesc, svr interface{}) {
// 		for i := range desc.Methods {
// 			md := desc.Methods[i]
// 			h := handleMethod(svr, desc.ServiceName, &md, unaryInt, &hOpts)
// 			mux(path.Join(basePath, fmt.Sprintf("%s/%s", desc.ServiceName, md.MethodName)), h)
// 		}
// 	})
// }

// Accepts incoming connections on the listener lis,
// creating new shm connections and a dedicated
// goroutine fo reach and then call the registered
// handles for then.
func (s *Server) Serve(lis *Listener) error {

	//Handle listener setup
	s.mu.Lock()
	log.Info().Msgf("serving")

	//TODO CASE HANDLING
	s.lis = lis

	s.mu.Unlock()
	//Begin Listen//accept loop
	//Sleep interval for null connect or previous connect
	var tempDelay time.Duration = 5
	// time.Sleep(2 * time.Second)

	// start := time.Now()
	for {
		newQueuePair, err := lis.Accept()

		// if time.Since(start) > time.Second*60 {
		// 	break
		// }

		if err != nil {
			//panic
			log.Error().Msgf("Accept error: %v", err)
			return err
		}
		// Check null or against map to backoff
		if newQueuePair == nil {
			log.Info().Msgf("null queue_pair: %v", newQueuePair)
			time.Sleep(tempDelay * time.Second)
			continue
		}
		s.mu.Lock()
		_, ok := s.conns[newQueuePair.ClientId]
		s.mu.Unlock()
		if ok { //Queue pair already exists
			log.Info().Msgf("already served queue_pair: %v", newQueuePair)
			// We are already servicing this queue
			time.Sleep(tempDelay * time.Second)
			continue
		} else {
			s.mu.Lock()
			s.conns[newQueuePair.ClientId] = newQueuePair
			s.mu.Unlock()
			//Start a new goroutine to deal with the new queuepair
			s.serveWG.Add(1)
			go func() {
				s.handleNewQueuePair(newQueuePair)
				s.serveWG.Done()
			}()
		}
	}
	return nil

}

// Fork a goroutine to handle just-accepted connection
func (s *Server) handleNewQueuePair(queuePair *QueuePair) {
	//Check for quit

	//Conn wrapper?

	//Deadline of inactivity?

	//Add to map
	// s.mu.Lock()
	// s.conns[queuePair.ClientId] = queuePair
	// s.mu.Unlock()

	log.Info().Msgf("New client connection: %v", queuePair)

	//Launch dedicated thread to handle
	go func() {
		s.serveRequests(queuePair)
		// If return from this method, connection has been closed
		// Remove and start servicing, close connection
		// s.closeConnection()
	}()
}

// Actually handles the incoming message flow from the client
// Invokes a go routine on a pre-declared handler function
func (s *Server) serveRequests(queuePair *QueuePair) {

	// defer close connection
	// var wg sync.WaitGroup
	buf := make([]byte, 512)
	b := bytes.NewBuffer(buf)
	//iterate and append to dynamically allocated data until all data is read
	var size int
	// s.serveWG.Add(1)
	for {
		size = queuePair.ServerReceiveBuf(buf, len(buf))
		s.prev_time = time.Now()
		// log.Info().Msgf("Server: Reads: %v", buf)

		b.Write(buf)
		if size == 0 { //Have full payload
			// log.Info().Msgf("handle request: %s", s.timestamp_dif())
			s.handleMethod(queuePair, b)

		}
	}
	// Call handle method as we read of queue appropriately.
}

func (s *Server) Context(ctx context.Context) context.Context {
	if ctx != nil {
		return ctx
	}
	return context.Background()
}

func (s *Server) handleMethod(queuePair *QueuePair, b *bytes.Buffer) {

	var json = jsoniter.ConfigCompatibleWithStandardLibrary

	// log.Info().Msgf("Server: Message Received: %v \n ", b.String())

	// Need a method to unmarshall general struct of
	// request, JSON for now
	// log.Info().Msgf("handle method: %s", s.timestamp_dif())
	var message_req_meta ShmMessage

	decoder := json.NewDecoder(b)
	err := decoder.Decode(&message_req_meta)
	if err != nil {
		log.Panic()
	}

	payload_buffer := []byte(message_req_meta.Payload)

	// log.Info().Msgf("unmarshal: %s", s.timestamp_dif())

	//Request context
	ctx := s.Context(message_req_meta.ctx)

	fullName := message_req_meta.Method
	strs := strings.SplitN(fullName[1:], "/", 2)
	serviceName := strs[0]
	methodName := strs[1]

	ctx, cancel, err := contextFromHeaders(ctx, message_req_meta.Headers)
	if err != nil {
		// writeError(w, http.StatusBadRequest)
		return
	}

	defer cancel()

	//Get Service Descriptor and Handler
	sd, handler := s.handlers.QueryService(serviceName)
	if sd == nil {
		// service name not found
		status.Errorf(codes.Unimplemented, "service %s not implemented", message_req_meta.Method)
	}
	// log.Info().Msgf("query service: %s", s.timestamp_dif())

	//Get Method Descriptor
	md := internal.FindUnaryMethod(methodName, sd.Methods)
	if md == nil {
		// method name not found
		status.Errorf(codes.Unimplemented, "method %s/%s not implemented", serviceName, methodName)
	}

	// log.Info().Msgf("find unary: %s", s.timestamp_dif())

	//Get Codec for content type.
	codec := encoding.GetCodec(grpcproto.Name)

	// Function to unmarshal payload using proto
	dec := func(msg interface{}) error {
		val := payload_buffer
		if err := codec.Unmarshal(val, msg); err != nil {
			return status.Error(codes.InvalidArgument, err.Error())
		}
		return nil
	}

	// Implements server transport stream
	sts := internal.UnaryServerTransportStream{Name: methodName}

	//Get resp write back
	resp, err := md.Handler(
		handler,
		grpc.NewContextWithServerTransportStream(ctx, &sts),
		dec,
		s.unaryInterceptor)
	if err != nil {
		status.Errorf(codes.Unknown, "Handler error: %s ", err.Error())
		//TODO: Error code must be sent back to client
	}
	// log.Info().Msgf("handle: %s", s.timestamp_dif())

	var resp_buffer []byte
	resp_buffer, err = codec.Marshal(resp)
	if err != nil {
		status.Errorf(codes.Unknown, "Codec Marshalling error: %s ", err.Error())
	}

	message_resp := &ShmMessage{
		Method:   methodName,
		ctx:      ctx,
		Headers:  sts.GetHeaders(),
		Trailers: sts.GetTrailers(),
		Payload:  ByteSlice2String(resp_buffer),
	}
	resp_buffer = nil

	var serializedMessage []byte

	serializedMessage, err = json.Marshal(message_resp)
	message_resp = nil
	// log.Info().Msgf("marshal: %s", s.timestamp_dif())
	if err != nil {
		status.Errorf(codes.Unknown, "Codec Marshalling error: %s ", err.Error())
	}

	// log.Info().Msgf("Server: Message Sent: %v \n ", serializedMessage)

	//Begin write back
	// message := []byte("{\"method\":\"SayHello\",\"context\":{\"Context\":{\"Context\":{\"Context\":{}}}},\"headers\":null,\"trailers\":null,\"payload\":\"\\n\\u000bHello world\"}")
	queuePair.ServerSendRpc(serializedMessage, len(serializedMessage))

}

// Shutdown the server
func (s *Server) Stop() {
	s.lis.notnets_context.Shutdown()
}

// contextFromHeaders returns a child of the given context that is populated
// using the given headers. The headers are converted to incoming metadata that
// can be retrieved via metadata.FromIncomingContext. If the headers contain a
// GRPC timeout, that is used to create a timeout for the returned context.
func contextFromHeaders(parent context.Context, md metadata.MD) (context.Context, context.CancelFunc, error) {
	cancel := func() {} // default to no-op

	ctx := metadata.NewIncomingContext(parent, md)

	// deadline propagation
	// timeout := md.Get("GRPC-Timeout")
	// if timeout != "" {
	// 	// See GRPC wire format, "Timeout" component of request: https://grpc.io/docs/guides/wire.html#requests
	// 	suffix := timeout[len(timeout)-1]
	// 	if timeoutVal, err := strconv.ParseInt(timeout[:len(timeout)-1], 10, 64); err == nil {
	// 		var unit time.Duration
	// 		switch suffix {
	// 		case 'H':
	// 			unit = time.Hour
	// 		case 'M':
	// 			unit = time.Minute
	// 		case 'S':
	// 			unit = time.Second
	// 		case 'm':
	// 			unit = time.Millisecond
	// 		case 'u':
	// 			unit = time.Microsecond
	// 		case 'n':
	// 			unit = time.Nanosecond
	// 		}
	// 		if unit != 0 {
	// 			ctx, cancel = context.WithTimeout(ctx, time.Duration(timeoutVal)*unit)
	// 		}
	// 	}
	// }
	return ctx, cancel, nil
}

// noValuesContext wraps a context but prevents access to its values. This is
// useful when you need a child context only to propagate cancellations and
// deadlines, but explicitly *not* to propagate values.
type noValuesContext struct {
	context.Context
}

// func makeServerContext(ctx context.Context) context.Context {
// 	// We don't want the server have any of the values in the client's context
// 	// since that can inadvertently leak state from the client to the server.
// 	// But we do want a child context, just so that request deadlines and client
// 	// cancellations work seamlessly.
// 	newCtx := context.Context(noValuesContext{ctx})

// 	if meta, ok := metadata.FromOutgoingContext(ctx); ok {
// 		newCtx = metadata.NewIncomingContext(newCtx, meta)
// 	}
// 	// newCtx = peer.NewContext(newCtx, &inprocessPeer)
// 	// newCtx = context.WithValue(newCtx, &clientContextKey, ctx)
// 	return newCtx
// }
